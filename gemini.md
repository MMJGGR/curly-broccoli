CFA-Compliant Personal Finance App (Kenya) – Development Roadmap
Milestone 1: Foundation & Architecture Setup
Monorepo and Workspace Initialization: Goal: Establish a unified codebase structure (e.g. frontend/, api/, compute/) for front-end (React + Vite) and back-end (FastAPI) per the reference architecture. Dependencies: Node.js, Python 3.10+, pnpm for workspaces. Deliverables: Repository with React 19 + Tailwind CSS app and FastAPI scaffold, both runnable. Testing: Basic linting and unit test frameworks (Jest for JS/TS, Pytest for Python) configured; require >90% coverage for any new module.
Docker Environment: Goal: Containerize services for dev/prod parity. Dependencies: Docker & docker-compose. Deliverables: Dockerfile for FastAPI, Node (if used), and React; a docker-compose.yml to run app, DB, Redis locally. Testing: docker-compose up brings up the stack and health endpoints respond.
Core Architecture Alignment: Goal: Adhere to guiding principles – pure-function compute core, thin React UI, stateless API. Dependencies: Team knowledge of functional design. Deliverables: Documentation of architecture decisions (e.g. no business logic in React, all logic in FastAPI endpoints). Testing: Code review check that React only renders data (no financial calculations in components), and FastAPI endpoints are side-effect free and idempotent.
Observability Setup (Initial): Goal: Implement baseline observability tools. Dependencies: FastAPI middleware for logging, OpenTelemetry libraries. Deliverables: A /healthz endpoint in FastAPI returning engine status matrix, request logging with trace IDs, and stub integration for metrics (to be expanded later). Testing: Hitting /healthz returns OK status for all engines (since none implemented yet), each response contains a trace ID header.
Milestone 2: User Authentication & Profile (KYC) System
User Accounts & JWT Auth: Goal: Provide secure user registration and login with JSON Web Tokens (stateless auth). Dependencies: FastAPI OAuth2 password flow (later upgradeable to OAuth2 social login), PyJWT; PostgreSQL for user store. Deliverables: Auth API endpoints (/register, /login) that issue JWTs on successful auth. Testing: Unit tests for login (valid credentials get token, invalid get 401), ensure JWTs contain correct claims and expiration; future-proof for MFA and OAuth2 extension.
Profile Data Model & KYC: Goal: Design a comprehensive user profile to capture KYC-level info needed for retirement/brokerage planning. Dependencies: PostgreSQL (with SQLAlchemy or similar ORM), encryption library (for PII). Deliverables: User Profile schema – fields for personal details (DOB, ID/Passport, KRA PIN, income, dependents, etc.), risk tolerance questionnaire scores, financial goals. Encrypt sensitive PII in the database (AES-256, keys in KMS). Testing: Database migration applied and verified; create a test user with full profile (e.g. Hadi’s data) and ensure data can be saved/retrieved (check encryption at rest).
Profile Management API: Goal: CRUD endpoints for profile & dependents info. Dependencies: JWT auth implemented; pydantic schemas for request/response. Deliverables: Endpoints like /profile GET/PUT (update profile), /dependents POST/GET etc. Testing: Integration tests simulating a user updating their profile (e.g., adding a spouse or child dependent) and retrieving it. Verify that unauthorized requests are rejected (stateless JWT enforcement).
Front-End User Onboarding Flow: Goal: Implement intuitive UI screens for onboarding and profile setup. Dependencies: React (Tailwind UI forms), form management library (if needed). Deliverables: Onboarding Component – multi-step form capturing personal info, financial status, goals (e.g. “Retire by age 60 with KES X” or “Start a business in 1 year”). Use the provided color scheme (main orange #FF9933 for call-to-action buttons, white #FFFFFF background, text #333333, subtle grays #CCCCCC/#DDDDDD for inputs, and #CC0000 for delete/remove actions). Testing: UX review with a non-tech persona (like Hadi) to ensure form is understandable; validate required fields and data formats (e.g. KRA PIN structure). Snapshot tests for React components and form state.
Future Security Prep: Goal: Lay groundwork for later OAuth2 login and MFA. Dependencies: None (planning task). Deliverables: Design doc outlining how Google OAuth or SMS/email MFA would integrate (token scopes, refresh tokens, etc.) without breaking stateless design. Testing: (Documentation) Review by security engineer; ensure JWT payload can accommodate MFA claims or OAuth scopes (no coding yet, just planning).
Milestone 3: Core Financial Engines – Part I (Income, Expenses, Loans, Tax)
MasterEngine Orchestration: Goal: Create the MasterEngine service in FastAPI that orchestrates sub-engines and compiles results. Dependencies: None (new module). Deliverables: /v1/calculate endpoint accepting a JSON payload (containing profile, assets, liabilities, etc.) and returning a consolidated report.json of computed projections. MasterEngine should hash-check the input and use a Redis cache for 24h cached results to improve performance on unchanged inputs. Testing: Unit test MasterEngine with a dummy sub-engine that returns a known value; test that repeated calls with identical payload hit cache (e.g., track a cache hit metric).
Income Engine: Goal: Compute yearly income projections and net income after taxes for the user’s working life. Dependencies: Profile data (current salary, salary growth rate, other income streams), Kenyan tax config. Deliverables: incomeEngine() pure function that, given user profile and timeline events, returns an array of yearly income values (gross and net) plus present value of future income. Include logic for PAYE tax brackets, personal relief, NSSF contributions (deductible), NHIF, and new levies (e.g. 1.5% housing levy if applicable). Use a static table for PAYE rates and reliefs loaded from config (updateable annually). Testing: Create tests for a few scenarios – e.g., a simple case of a fixed salary vs. known PAYE outcome (ensure computed PAYE matches official tables), a scenario where salary increases or a new income source starts at a future date (event simulation), and edge cases like income below taxable threshold. Verify that marking pension contributions as pre-tax reduces taxable income.
Expense Engine: Goal: Project annual expenses throughout the timeline. Dependencies: User’s current expense breakdown, inflation assumptions. Deliverables: expenseEngine() that returns yearly expense estimates (categorized if needed) plus present value of future expenses. Incorporate life events: for example, increase expenses on marriage or birth of a child, include one-time goal expenses (like buying a house) in the respective year. Testing: Unit test that expenses grow with inflation rate; if an event “Childbirth” is in year 3, ensure engine adds child-related costs from that year onward. Test that optional large goals (from profile’s goals list) are included at correct timeline points.
Loan Engine: Goal: Integrate liabilities (loans/mortgages) into the financial projection. Dependencies: Current loans (principal, interest rate, term) from profile. Deliverables: loanEngine() that produces amortization schedules for each loan and aggregates yearly loan payments (and remaining balances). It should flag the payoff date and monthly payment for each loan. Testing: Given a sample loan (e.g. KES 1M at 10% over 5 years), verify the engine returns correct annual interest vs principal breakdown and that loan balance hits zero by maturity. Test edge cases like interest-only loans or balloon payments if any. Ensure that if a “buy house” event adds a new mortgage, the engine can incorporate that new loan dynamically.
Tax Calculation Integration: Goal: Ensure accurate Kenyan tax and deduction calculations are applied across engines. Dependencies: Tax rules (config tables), outputs from incomeEngine & others. Deliverables: Tax module (could be part of income engine or a shared utility) that computes PAYE, NHIF, NSSF, and levies. If early pension withdrawal occurs, apply PAYE on withdrawal amount per tax rules. Testing: Use known tax scenarios – e.g., a salary that spans multiple PAYE brackets to confirm each bracket’s tax is applied correctly; ensure personal relief is applied once; test NSSF new rates (Tier I/II) and that the taxable income is reduced by pension contributions when flagged. These tests should mirror official PAYE examples to validate accuracy.
Deliverable & Integration: The /v1/calculate endpoint now returns a partial financial report covering incomes, expenses, and loan payments year-by-year. This should feed into a front-end dashboard (stub). Testing: End-to-end call using a test payload (with dummy data) returns a JSON with expected keys (income, expenses, etc.) and plausible values. Use a persona (e.g. Hadi’s current finances) to manually verify the output: e.g., ensure Hadi’s net income after tax matches what a Kenyan payslip calculator would show, and loan payoff aligns with schedule.
Milestone 4: Core Financial Engines – Part II (Investments, Retirement, Insurance, Alerts)
Investment Engine: Goal: Project growth of investments and asset allocation over time, aligned with user goals and risk profile. Dependencies: Current assets from profile (savings, stocks, etc.), user’s risk tolerance (from KYC questionnaire), market return assumptions. Deliverables: investmentEngine() that simulates portfolio value year-by-year. Incorporate contributions (e.g., regular savings or one-time investments), withdrawals for goals, and an asset allocation strategy (e.g., more equity when young, shift to bonds as user ages or as per risk profile). If the user plans to “start a business next year” (event), allow for a withdrawal of capital in that year. Testing: Financial scenario tests – e.g., if user invests KES 100k/year with 5% return, does the engine’s output match compound growth expectations? Test risk-profile adjustments: a risk-averse profile should simulate more conservative growth vs. an aggressive profile (verify asset allocation shifts accordingly).
Retirement Engine: Goal: Determine retirement readiness and simulate pension outcomes. Dependencies: Retirement age goal from profile, current retirement savings (provident fund, pension schemes), Kenyan pension rules. Deliverables: retirementEngine() that evaluates when the user can retire given their projected finances. This engine should calculate the future value of retirement assets, apply annuity or drawdown models to see if they can sustain desired retirement income, and incorporate state pension (NSSF payouts or any govt social security) and employer schemes. Critically, handle early retirement cases: apply PAYE taxes on any early pension withdrawals and enforce minimum retirement age rules. Testing: Scenario tests – e.g., if the user’s goal is to retire at 60 with KES 100k/month need, verify the engine can determine if assets suffice or how many years short they are. Test early withdrawal: simulate user taking out pension at 50; engine should compute tax per PAYE table on that withdrawal. Ensure pension contributions in the simulation reduced taxable income as expected.
Insurance Engine: Goal: Evaluate insurance needs and outcomes for events like disability, death, medical emergencies. Dependencies: Profile data on dependents, current insurance coverage, income (for life insurance need). Deliverables: insuranceEngine() covering key personal risk areas – e.g., calculates recommended emergency fund size (e.g., 6 months of expenses), life insurance coverage needed (e.g., to replace income for X years for dependents), disability income coverage, and medical insurance gaps. It may integrate local insurance cost data (e.g., premium rates from Kenyan insurers) or use average factors if exact product data not available. Testing: Check outputs against known rules of thumb: if user has 2 dependents and KES Y income, life cover suggested might be ~10-15× Y; ensure emergency fund recommendation equals a few months of expenses. If the user profile already has some insurance, ensure the engine only flags shortfall.
Alert Engine: Goal: Provide users with actionable insights and warnings based on the combined financial plan. Dependencies: Outputs of all other engines (income, expense, loan, investment, retirement, insurance). Deliverables: alertEngine() that analyzes the consolidated report for any issues. Examples: “⚠️ Shortfall: You cannot afford to start the business in 1 year without depleting savings” or “✅ On track: Retirement goal at 60 is achievable.” Alerts can be of type info, warning, or error (echoing the observability principle that each engine returns ok/warning/error). Testing: Simulate various personas: one with too high expenses vs income (expect a warning about budgeting), one with insufficient retirement savings (alert suggesting increased saving or delayed retirement), and one meeting all goals (perhaps only informational alerts). Each scenario should trigger the correct alert severity. Confirm that all engine outputs are considered in generating alerts.
Integrate & Validate Full Compute Pipeline: With all sub-engines implemented, the MasterEngine now produces a complete financial report for a user’s life timeline, combining incomes, expenses, loan balances, investment growth, insurance needs, and retirement outlook. Dependencies: All engines above integrated in MasterEngine flow. Deliverables: Updated /v1/calculate that returns the full report (e.g., JSON structure with yearly projections up to, say, age 90 or a set horizon). Also, an export function to save a snapshot of the report (e.g., to cloud storage) with a timestamp. Testing: Regression-test with a known complex profile (like Hadi’s profile data in the system) – verify that the outputs make sense compared to that user’s manual financial plan. For example, ensure net worth projection matches within ±5% of a reference calculation and all key metrics (retirement age feasible, insurance recommended) align with professional expectations. Each engine should also have near 100% unit test coverage (pure functions), and a integration test ensures that changes in one engine (e.g., increased expense) reflect appropriately in the final combined output.
Milestone 5: User Interface & Experience (Planning & Visualization)
Dashboard & Timeline View: Goal: Create a modern, intuitive dashboard for users to visualize their life financial timeline. Dependencies: Completed backend /calculate report JSON, charting library (e.g., D3.js or Chart.js) for timeline. Deliverables: Dashboard Page – shows a high-level summary (current net worth, projected net worth over time, financial independence age, etc.), and an interactive timeline (e.g., a chart of cash flow or net worth by year). Users should see milestones (e.g., “🏠 Bought House”, “🧑‍🎓 Child to University”, “💼 Business Start”, “🎂 Retirement”) plotted on the timeline. Implement color scheme thoroughly: e.g., use Main Orange (#FF9933) for highlights or progress bars, Primary Text (#333333) for text, Subtle Grey (#CCCCCC) for gridlines or secondary info. Testing: Usability testing with a sample user – can they understand the timeline chart? Ensure that hovering on a year shows details (income vs expense vs investment balance for that year). Automated front-end tests for rendering with a sample report JSON.
Life Event Management UI: Goal: Allow users to input and manage life events and see their impact. Dependencies: Timeline data model in backend, state management in frontend (could use Redux or React Context for events before submission). Deliverables: Planning/Timeline Editor – UI form or drag-and-drop interface to add events (marriage, home purchase, new child, business start, etc.) with a year or age. These events should instantly reflect in the projected outcomes (either by re-calling the API or locally simulating until API confirmation). Testing: Verify adding an event updates the plan: e.g., user adds an event “Start Business in 2026 costing KES X investment” – after API recompute, the dashboard updates showing a dip in assets in 2026 and perhaps an alert if cash goes negative. Use integration test to add and remove events and assert that results change accordingly (the test could use a controlled backend stub if needed).
Profile & Goals UI: Goal: Front-end screens for viewing/editing the detailed profile (from Milestone 2) and long-term goals. Dependencies: Profile API, maybe a state management solution for form state. Deliverables: Profile Page – shows personal info and financial details with edit capability; Goals Section – allows setting goals (retirement age, target home purchase, children education funding, etc.). These goals feed into the timeline and engines. Testing: Ensure that updating profile data (like salary or adding a dependent) triggers a re-calculation or prompts user to recalc plan, and the UI updates accordingly. Use React testing library to test form input and that new data is reflected in the store.
Reports & Exporting: Goal: Provide a way for users to get a summary report of their financial plan. Dependencies: Back-end snapshot/ report data, a PDF generation library (or front-end print styles). Deliverables: Export Functionality – e.g., a “Download Plan” button that generates a PDF report or CSV of key projections. The report should be based on the JSON output (which is identical to front-end schema by design). Testing: If PDF, generate for a test profile and visually verify layout (contains timeline chart, list of events, key metrics, and recommendations). If just data export, verify that all fields map correctly from JSON to exported format.
UX Review and Iteration: Goal: Refine the UI/UX to be human-centered and approachable. Dependencies: Initial user feedback (could be internal testers acting as end-users). Deliverables: Collect feedback from at least 3 users (developers or target users) using the app without developer help. Summarize pain points or confusions. Implement UI changes such as better tooltips, help modals explaining financial concepts (e.g., what “Present Value” means), etc. Ensure the color scheme and design are consistent and accessible (check contrast for text #333333 on white, etc.). Testing: Conduct a moderated user test scenario: e.g., ask a tester to “See if you can figure out when you can retire given your profile” and observe if the app effectively guides them. Address any issues (like unclear labels or navigation).
Milestone 6: Infrastructure, Security & Deployment
Backend Hardening & Observability: Goal: Make the backend production-ready with robust observability and security. Dependencies: FastAPI middleware, logging, monitoring tools. Deliverables: Integrate a structured logging solution (e.g., JSON logs with user ID and trace IDs for each request). Set up application metrics (e.g., engine execution time, cache hits) and distributed tracing (OpenTelemetry) exporting to a monitoring stack. Implement feature flag support (e.g., LaunchDarkly client) to toggle new features gradually. Testing: Intentionally trigger an error in one engine (e.g., divide by zero) and ensure the error is logged with trace info and returned as part of the health status matrix. Verify a sample feature flag can disable one engine’s output for testing. Security test: run dependency scans (SBOM) and vulnerability scans as part of CI.
Docker & CI/CD Pipeline: Goal: Streamline build, test, and deployment processes. Dependencies: Docker (images already defined), GitHub Actions (or similar CI). Deliverables: CI pipeline that lints, tests, builds Docker images for frontend and backend, and generates a Software Bill of Materials (SBOM) for compliance. On success, push images to container registry. CD setup using ArgoCD with a Helm chart for the app. Configure blue-green deployment strategy so new versions roll out with minimal downtime. Testing: Simulate a commit – ensure the CI runs tests and builds images. For CD, deploy to a staging environment: check ArgoCD picks up the new image and deploys pods. Write a basic smoke test that runs after deploy (hitting health endpoint and maybe a test calculation) to confirm the app is live.
GCP Infrastructure (Nairobi region): Goal: Prepare cloud infrastructure in the Nairobi (africa-east1) region for production deployment. Dependencies: GCP account, Terraform or gcloud for provisioning. Deliverables: Create a GKE cluster in Nairobi (or closest available region if not GA), a Cloud SQL PostgreSQL instance (for user data) and configure VPC connectivity, and a Redis (MemoryStore or VM) for caching. Set up a Cloud Storage bucket for storing immutable report snapshots. Testing: Deployment to a dev namespace in GKE: ensure app can connect to Cloud SQL (run migrations, then verify data operations), Redis cache, and save a file to Cloud Storage. Perform a load test for a few concurrent calculations to ensure the cluster auto-scales and responses remain <2s.
Data Security & Compliance: Goal: Enforce data residency and security requirements for enterprise compliance. Dependencies: KMS for encryption keys, compliance policies. Deliverables: All personal data storage to reside in-country (Kenya) as required – confirm GCP resources (DB, storage) are in Nairobi region. Encrypt PII at rest in the database (already done via KMS) and in transit (enforce TLS everywhere). Implement regular data backup and an audit log of data access. Testing: Audit that no PII (e.g. ID numbers) is stored in plaintext in logs or DB. Penetration test (or at least run OWASP ZAP on the API) to catch common vulnerabilities (XSS, SQL injection – use ORM parameterization to prevent these). Compliance review: ensure the architecture aligns with any relevant financial data regulations in Kenya and CFA ethics (e.g., confidentiality of client data).
Go-Live Checklist: Goal: Finalize the production readiness of the system. Dependencies: All prior tasks complete, domain name for the service. Deliverables: Documentation and scripts for deploying to production: environment variables, secrets in GCP Secret Manager, domain and TLS cert (maybe behind API Gateway or GKE Ingress with certs). Set up monitoring alerts (PagerDuty or Cloud Monitoring) for errors or resource usage. Define an incident response plan. Testing: Run a final full-system test in a staging environment with multiple personas (Hadi and at least two other sample users with different scenarios). Have non-developers go through their scenarios as a UAT. Only proceed when all critical issues are resolved and performance is acceptable.
Milestone 7: Continuous Testing & User Validation
Scenario Testing with Persona Data: Goal: Validate the system against real-life inspired scenarios on an ongoing basis. Dependencies: Persona profiles (like Hadi’s detailed financial data from provided spreadsheets). Deliverables: A test suite of scenario files – e.g., JSON profiles for Hadi (mid-career professional), a fresh graduate, a near-retiree – to run through /v1/calculate. Use expected outcomes (from manual calculations or expert-provided benchmarks) to assert the engines’ results are reasonable (within an acceptable error margin). Testing: Automate this test suite to run in CI. For Hadi’s profile, for instance, ensure the projected retirement age and cash flows align with his IPS (Investment Policy Statement) assumptions. Discrepancies beyond ±5% in key metrics should fail tests, prompting investigation.
End-to-End Behavioral Tests: Goal: Ensure the entire user journey works as intended with no regression. Dependencies: Cypress or Playwright for end-to-end testing. Deliverables: Automated browser tests simulating a user’s flow: sign up → complete profile → add life events → view dashboard → adjust a goal → log out. Include variations like returning user login and checking that data persists correctly. Testing: These E2E tests should run on each deployment (maybe in staging) and must all pass. Also include an accessibility testing step (using Lighthouse or axe) to ensure the UI meets a11y standards (color contrast, keyboard navigation, etc.).
Continuous Feedback Loop: Goal: Continuously improve based on user feedback and new data. Dependencies: Feedback channels (in-app feedback form or surveys). Deliverables: Set up a mechanism for users to report issues or suggestions. Schedule periodic (e.g., bi-weekly) reviews of incoming feedback and incorporate into backlog. As part of Kanban process, every new feature or bug fix card should include how it was tested and validated by a user persona scenario. Testing: Not applicable as a code test, but perform retrospective on each sprint/milestone: did the features delivered actually solve the user questions like “Can I afford X?” effectively? If not, refine requirements for next iteration.
Performance and Load Testing: Goal: Ensure the app remains performant for enterprise scale usage. Dependencies: Locust or JMeter for load test, profiling tools. Deliverables: Simulate high usage (e.g., 100 concurrent users calculating plans) to evaluate system throughput and latency. Identify bottlenecks in engines (e.g., if investment simulation is too slow, consider optimization or caching). Testing: Define performance budgets (e.g., each calculation < 2 seconds for typical profile). Automate a load test in CI that runs nightly or on-demand. If performance degrades beyond threshold, flag it to the team.
Final User Acceptance & Launch: Goal: Get a final go/no-go from a user-perspective test and launch the product. Dependencies: All features complete, no high-severity bugs. Deliverables: Conduct a user acceptance testing session with a small group of target users (including a financial advisor if available for CFA compliance check). Have them go through key tasks: set up profile, simulate an event, check recommendations. Gather any last-minute issues. Prepare a launch document highlighting the app’s capabilities, how it adheres to CFA ethical standards (e.g., transparency, accuracy), and areas for future expansion (such as integrating actual bank data or advisor chat). Testing: Verify that all acceptance criteria from the project kickoff are met. This includes cross-checking that each requirement (dynamic timeline, tax integration, KYC, etc.) is demonstrated in the final product. Once signed off, proceed to production deployment and announce the launch.
Each of these milestones is structured to be Kanban-friendly, with tasks broken down into actionable subtasks that have clear goals, dependencies, and deliverables. Developers of all skill levels should be able to pick up a subtask (e.g., Implement Income Engine or Design Profile UI Form) and understand exactly what is needed. By following this roadmap, the team ensures that the resulting application is robust, user-centric, and compliant with both Kenyan regulations and professional financial planning standards. All tasks are interwoven with continuous testing and validation, ensuring that by the time of launch, the app has been rigorously vetted against realistic user scenarios and strict quality benchmarks. The end result will be a modern personal finance platform that helps Kenyan users answer life’s big financial questions with confidence, like “Can I afford to start a business next year?” or “When can I comfortably retire?”, backed by solid calculations and an intuitive, supportive user experience.